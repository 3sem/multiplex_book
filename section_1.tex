\sloppy

\chapter{Обработка событий на множестве файловых дескрипторов}
\label{ch:chap1}

\section{Мультиплексирование ввода-вывода}

Мультиплексирование ввода-вывода -- это техника, позволяющая процессу или потоку отслеживать несколько файловых дескрипторов и получать уведомления, когда системный ресурс, абстрагированный каким-либо из этих дескрипторов, готов к операциям ввода-вывода (например, к чтению или записи). 

Данная техника часто используется в операционных системах для эффективного управления несколькими операциями ввода-вывода на сценариях, где один процесс или поток должен обрабатывать множество файловых дескрипторов, абстрагирующих сетевые сокеты, каналы связи, файлы или другие примитивы взаимодействия.
Подобный сценарий обработки зачастую реализуется в сетевых приложениях, таких как серверы, которым необходимо обрабатывать несколько клиентских подключений одновременно, в силу того, что организовывать обработку по принципу <<один процесс(поток) на соединение>> при большом количестве соединений -- расточительно\cite{epoll}.  

\section{Варианты оповещения о готовности дескрипторов}
Прежде чем переходить к рассмотрению реализации обработки множества дескрипторов, опре
деленим 2 модели оповещения о готовности дескриптора к обработке\footnote{Данные модели в целом характерны для систем цифровой обработки сигналов или дискретных событий}:

\begin{enumerate}
	\item Срабатывание по фронту (<<edge-triggered>>) -- оповещение происходит по факту события ввода-вывода на дескрипторе
	\item Срабатывание по уровню (<<level-triggered>>) -- оповещение происходит по готовности дескриптора быть обработанным, к примеру, по наличию данных, готовых для чтения без блокировки
\end{enumerate}

Для возможности работать с данными без блокировок нас будут в первую очередь интересовать примитивы, поддерживающие модель срабатывания по уровню. Тем не менее, некоторые из рассматриваемых в данном пособии примитивов поддерживают и срабатывание по фронту, например, epoll \cite{epoll}. Следует также отметить, что рассматриваемые примитивы с моделью срабатывания по уровню не гарантируют отсутствие блокировок, так как не изменяют режим работы с дескриптором, а лишь указывают о возможности такой работы. Блокировка может возникнуть, к примеру, в ходе операции записи большого количества данных \cite{kerrisk}.

\section{Варианты реализации обработки множества дескрипторов}

Рассмотрим основные варианты обработки событий на множестве дескрипторов в рамках одного потока\footnote{В данном пособии не рассматриваются как многопоточные, так и асинхронные варианты обработки событий, основанные на вызове со-программ, POSIX AIO, либо на основе сигналов} в режиме срабатывания по уровню. В качестве примера, демонстрирующего целесообразность использования мультиплексирования для данного сценария, выберем простейший пример ожидания готовности данных для чтения на фиксированном множестве дескрипторов. 

Предположим, существует однопоточное приложение, в котором производится чтение по нескольким дескрипторам, хранящимся в массиве \verb|fds|. Заранее неизвестно, в каком порядке и какого размера данные будут доступны для чтения. Следовательно, для решения задачи вычитывания данных по мере их готовности\footnote{При этом опустим даже требования соблюдения строгого порядка в вычитывании на дескрипторах}, требуется дожидаться готовности данных для каждого из дескрипторов, чтобы решить задачу корректно. Рассмотрим варианты реализации такой программы, использующие блокирующий, неблокирующий и мультиплексирующий подходы.

\begin{enumerate}
	\item Блокирующий подход. Подход применяется по умолчанию в большинстве современных операционных систем общего назначения: в случае, если данные не готовы, производится блокировка потока средствами операционной системы до тех пор, пока данные не станут доступны. Далее разблокированный поток может считать порцию готовых данных без блокировки. Следовательно, в случае, если производится проверка готовности данных на дескрипторах с перечислением дескрипторов в массиве \verb|fds| по возрастанию индексов, неготовность данных на дескрипторе \verb|fds[i-1]| заблокирует \verb|read(fds[i-1],...)| до моменда их готовности, а данные на \verb|read(fds[i],...)| все это время не будут считаны, даже если они были готовы ранее, чем на \verb|fds[i-1]|.
	
	\item Неблокирующий подход. В случае, если для файлового дескриптора установлен флаг \verb|O_NONBLOCK|, что можно выполнить при открытии файла либо при настройке посредством \verb|fcntl|, вызов \verb|read| будет обрабатывать дескриптор в неблокирующем режиме. Это означает, что в случае, если данные не готовы, вызов моментально вернет управление, с соответствующим кодом возврата -1 и ошибкой \verb|EAGAIN|(11), не переводя вызвавший поток в состояние ожидания готовности данных. В случае готовности данных, поведение вызова не будет отличаться от поведения при блокирующем подходе. Следовательно, для организации программы в таком неблокирующем режиме требуется завести цикл, производящий попытку прочитать данные на каждом из дескрипторов на каждой итерации. Фактически, функция примитива ожидания выполняется данным циклом, именуемым в литературе активным циклом ожидания. Ожидание называется активным в силу того, что потребляет процессорное время. Несмотря на то, что во многих случаях подобные циклы считаются анти-шаблоном проектирования ПО, в отдельных сценариях, для которых либо априори известно, что количество итераций данного цикла невелико\footnote{К примеру, в спин-блокировках в ядре ОС, спроектированных с целью обеспечения эксклюзивного доступа к готовым данным}, либо требуется обеспечить лучшую интерактивность по сравнению с блокирующим решением\footnote{Заметим, что возврат из вызова в случае неготовности данных происходит условно быстро}, такое решение преемлемо. Тем не менее, оно очевидно не является преемлемым для высоконагруженных сетевых приложений, обрабатывающих большое количество сетевых соединений, так как за $n>>1$ итераций цикла будет производиться $n$ вызовов, вносящих дополнительные накладные расходы в деятельность приложения.
	\item Мультиплексирующий подход. В данном подходе ожидание происходит на специальном системном вызове, производящем мониторинг некоторых событий на множестве дескрипторов. Возврат управления происходит либо если данные события произошли, либо по другим условиям, например, по истечении некоторого интервала времени. Далее определеляется подмножество дескрипторов, готовых к обработке\footnote{Как будет показано далее, алгоритмическая сложность определения может лежать от $O(1)$ до $O(n)$ для $n$ наблюдаемых дескрипторов, в зависимости от семейства вызовов} обычными вызовами чтения/записи.
\end{enumerate}





\section{Мультиплексирование ввода-вывода в Linux}

Мультиплексирование ввода-вывода в Linux представлено тремя семействами механизмов\footnote{Семействами, так как в каждое из семейств входит несколько системных вызовов, к примеру poll и ppoll}: \verb|select|, \verb|poll|, \verb|epoll|\footnote{Данный механизм часто выделяют в отдельный тип взаимодействия, так как он сочетает в себе элементы и мультиплексирования, и обработки на основе сигналов\cite{kerrisk}}. Семейство определяет <<стить>>, в котором осуществляется мультиплексирование и особенности работы с событиями и дескрипторами. Также существует ряд сторонних библиотек, предоставляющих унифицированный интерфейс для мультиплексирования, к примеру, \verb|libevent|. В данном пособии они не рассматриваются.

\subsubsection{Вызов select}    

Вызов \verb|select| (<<выделить>>) стандартизирован по POSIX и является наиболее широко портированным из всех существующих средств мультиплексирования.
\verb|select| реализует модель срабатывания по уровню.

Прототип функции для работы с \verb|select| средствами \verb|libc| объявлен в заголовочном файле \verb|sys/select.h| и имеет вид: \\

%\verb|int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds,|

%\hspace{44pt}\verb|fd_set *restrict exceptfds, struct timeval *restrict timeout);|,\\ 

\verb|int select(int nfds, fd_set *readfds,|

\hspace{62pt}\verb|fd_set *writefds, fd_set *exceptfds, |

\hspace{62pt}\verb|struct timeval *timeout);|,
\\ 
Где:
\begin{itemize}
	\item \verb|nfds| -- максимальный номер дескриптора во всех наблюдаемых множествах плюс 1.
	\item \verb|readfds|, \verb|writefds|, \verb|exceptfds| -- указатели на множества дескрипторов, наблюдаемых на готовность чтения, записи, либо на исключительные ситуации соответственно.
	\item \verb|timeout| -- указатель на структуру, содержащую значение времени до тайм-аута ожидания событий. Если тайм-аут задан как 0, вызов завершится без блокировки. В противном случае, либо если тайм-аут не задан (указатель равен NULL), произойдет блокировка вызвавшего потока до истечения тайм-аута, либо до возникновения событий, ассоциированных с дескрипторами из наблюдаемых множеств.
\end{itemize}

Работа с множествами дескрипторов осуществляется посредством соответсвующих макроопределений из \verb|sys/select.h|, в частности:

\begin{itemize}
	\item \verb|FD_ZERO(&fds)| -- инициализировать пустое множество дескрипторов \verb|fds|.
	\item \verb|FD_SET(n, &fds)|,\verb|FD_CLR(n, &fds)|  -- добавить либо соответственно удалить дескриптор $n\leq$ \verb|FD_SETSIZE| из \verb|fds|, где \verb|FD_SETSIZE| -- максимально возможный номер дескриптора, определенный как 1024 в заголовочных файлах Linux\cite{linux_posix_types}. Поведение при $n>$ \verb|FD_SETSIZE| не определено. Таким образом, \verb|select| не поддерживает одновременную работу с числом дескрипторов, превышающим \verb|FD_SETSIZE|.
	
	\item  \verb|FD_ISSET(n, &fds)| -- проверить, что произошло событие, ассоциированное с дескриптором $n$ из \verb|fds|.
\end{itemize}

По истечении интервала времени, заданного \verb|timeout|, без произошедших событий, вызов вернет 0. В случае ошибки, вызов возвращает -1, а код ошибки можно получить из \verb|errno|.

Если во время наблюдения произошли события, вызов вернет число дескрипторов, с которыми данные события ассоциированы. Далее требуется определить, какие именно это дескрипторы, осуществив проверку значения \verb|FD_ISSET| для каждого из дескрипторов в соответствующих множествах. В случае, если оно ненулевое, с данным дескриптором можно совершить работу обыкновенными вызовами ввода-вывода без блокировки. Таким образом, сложность поиска конкретных дескрипторов, на которых произошли события, составляет $O(N)$, где $N=|readfds| + |writefds| + |exceptfds|$. В силу того, что вызов модифицирует саму структуру множеств, повторно использовать их не допускается, и нужно совершать переинициализацию.

С целью возможности изменения маски сигналов на время вызова, а также с целью достичь большей гранулярности по времени, и, как результат, большей точности\footnote{Что зависит от точности программных таймеров, и, вообще говоря, не гарантируется для систем общего назначения}, существует вызов \verb|pselect| \cite{pselect}, принимающий в качестве аргумента тайм-аута структуру \verb|struct timespec|, а также 6-й аргумент -- маску сигналов типа \verb|sigset_t|, которая выставляется потоку непосредственно перед началом наблюдения и заменяется на исходную непосредственно после.


\subsubsection{Вызов poll}
Вызов \verb|poll| (<<опрос>>), стандартизированный по XPG4-UNIX, был разработан позже \verb|select| с целью ликвидации ряда недостатков последнего, также реализует срабатывание по уровню. В первую очередь, в \verb|poll| была решена проблема модификации структур, содержащих информацию о наблюдаемых дескрипторах, что достигнуто благодаря использованию специальной структуры \verb|struct pollfd| описания наблюдаемого дескриптора, в которой поля настроек событий и статуса наблюдений -- суть разные поля. Также \verb|poll| не имеет ограничения \verb|FD_SETSIZE| по числу дескрипторов, и не требует определять максимальный номер дескриптора. 


Прототип функции для работы с \verb|poll| средствами \verb|libc| объявлен в заголовочном файле \verb|poll.h| и имеет вид: \\

\verb|int poll(struct pollfd fds[], nfds_t nfds,int timeout)|,\\
Где:
\begin{itemize}
	\item \verb|fds| -- массив структур описания дескрипторов.
	\item \verb|nfds_t| -- количество дескрипторов в fds.
	\item \verb|timeout| -- тайм-аут в миллисекундах. В случае указания -1 вызов будет бесконечно ожидать первого события, в случае 0 -- завершится без блокировки.
\end{itemize}

Настройка элементов \verb|fds| производится следующим образом:
в поле \verb|fds[i].fd| присваивается номер наблюдаемого дескриптора, в поле \verb|events| -- маска наблюдаемых событий, к примеру \verb|POLLIN| | \verb|POLLOUT|. После возврата \verb|poll| статус события можно проверить, проверив условие взведения соответсвующих бит в \verb|revents| для каждого из дескрипторов, к примеру: 

\verb|if (fds[i].revents & POLLIN) {...| 

\hspace{22pt}// можно читать без блокировки \verb|}| \\
Таким образом, временная сложность определения конкретных дескрипторов составляет $O(N)$, как и в случае с \verb|select|.

По истечении тайм-аута, \verb|poll| возвращает 0. В случае готовности некоторых из наблюдаемых дескрипторов -- число готовых к обработке без блокировки, в случае ошибки -- -1, с кодом ошибки в \verb|errno|. 

Задание \verb|timeout| в миллисекундах вносит ограничение в гранулярность интервалов времени, за которые \verb|poll| наблюдает за дескрипторами. С целью возможности изменения маски сигналов на время вызова, аналогично вызову \verb|pselect|, а также с целью достичь большей гранулярности по времени, и, как результат, большей точности$^7$, существует вызов \verb|ppoll| \cite{poll}, принимающий в качестве аргумента тайм-аута структуру \verb|struct timespec|, а также 4-й аргумент -- маску сигналов типа \verb|sigset_t|.

\subsubsection{Механизм epoll}
Linux-специфичный механизм \verb|epoll| (<<event-poll>>--<<опрос событий>>), добавленный в ядро начиная с версии 2.5.45, обеспечивает лучшую масштабируемость на большое число дескрипторов, нежели \verb|select| и \verb|poll|. Помимо данного ключевого свойства, \verb|epoll| позволяет получить перечень дескрипторов, на которых произошли события, за $O(1)$. 

Интерфейс работы с \verb|epoll| относительно громоздок, и включает в себя несколько вызовов и структур, объявленных в \verb|sys/epoll.h|. Ключевым элементом этого интерфейса является дескриптор \verb|epoll|, используемый для двух целей -- сохранение и настройка списка наблюдаемых дескрипторов -- <<списка интереса>>, и получение списка дескрипторов, готовых к вводу-выводу -- <<списка готовности>>. По выполнении управляющего вызова -- \verb|epoll_ctl|, в который передается информация о \verb|epoll|-дескрипторе и о наблюдаемых дескрипторах, ядро осуществляет наблюдение за открытыми файлами, с которыми дескрипторы ассоциированы, и добавляет записи для готовых дескрипторов в <<список готовности>> в через механизм обратных вызовов. Записи данного списка будут прочитаны вызовом \verb|epoll_wait|.

Создание экземпляра \verb|epoll|-примитива происходит одним из вызовов:
\begin{enumerate}
	\item \verb|int epoll_create(int size)| -- создать экземпляр с ограничением в \verb|size| наблюдаемых дескрипторов. Вызов устарел, на современных версиях ядра \verb|size| игнорируется.
	\item \verb|int epoll_create1(int flags)| -- создать экземпляр, настраеваемый флагами во \verb|flags|\cite{epoll_man}.
\end{enumerate}
В случае, если в 
В случае ошибки, вызовы возвращают -1. В 
случае успеха -- дескриптор, ассоциированный с экземпляром \verb|epoll|.

Добавление, модификация и удаление наблюдаемых дескрипторов выполняется вызовом \verb|epoll_ctl|:

\verb|int epoll_ctl(int epfd, int op,int fd, |

\hspace{80pt}\verb|struct epoll_event *_Nullable event)|, \\
Где:
\begin{itemize}
	\item \verb|epfd| -- дескриптор \verb|epoll|
	\item  \verb|op| -- операция, задаваемая масками \verb|EPOLL_CTL_ADD|,\verb| EPOLL_CTL_MOD|, \verb|EPOLL_CTL_DEL|, добавления, модификации или удаления дескриптора соответсвенно
	\item \verb|fd| -- наблюдаемый дескриптор
	\item \verb|event| -- указатель на структуру, поле \verb|events| которой является битовой маской настройки наблюдаемых событий, например, \verb|EPOLLIN|. Если в данной маске не выставлен \verb|EPOLLET|, данный дескриптор будет обрабатываться в режиме срабатывания по уровню, иначе -- по фронту. Поле \verb|data| -- специфицирует данные, которые ядро должно возвращать в вызов опроса --\verb|epoll_wait| -- при возникновении событий на дескрипторе. 
\end{itemize}

Вызов опроса -- \verb|epoll_wait|:

\verb|int epoll_wait(int epfd, struct epoll_event *events,|

\hspace{86pt}\verb|int maxevents, int timeout)|,\\
Где:
\begin{itemize}
	\item \verb|epfd| -- дескриптор \verb|epoll|
	\item \verb|events| -- указатель на на начало области памяти, в которой структуры структуры описания детектированных событий. Очевидно, область должна быть доступна на запись, в противном случае возникнет ошибка \verb|EFAULT|.
	\item \verb|maxevents| -- верхнее ограничение количества детектированных событий.
	\item \verb|timeout| -- тайм-аут. Значение -1 означает бесконечное ожидание, значение 0 -- возврат без блокировки, иные значения -- значения тайм-аута в миллисекундах.
\end{itemize}

Вызов в случае успеха возвращает количество дескрипторов, готовых к обработке, и -1 в случае ошибки.




\subsubsection{Оценки производительности}

Особенностью вызовов \verb|select| и \verb|poll| является передача в каждый вызов множеств отслеживаемых дескрипторов, которые в свою очередь передаются в ядро, а по возврату из вызова ядро передает обратно структуру, описывающую факт готовности каждого из дескрипторов. При таком подходе ядро должно проверить все дескрипторы, указанные в вызове, поэтому следует ожидать линейную зависимость времени отклика \verb|select| и \verb|poll| от количества отслеживаемых дескрипторов. В случае \verb|epoll|, дескрипторы передаются в \verb|epoll_ctl|, и на момент вызова \verb|epoll_wait| ядру они уже известны, а запись фактов о событиях ввода-вывода на дескрипторах организуется добавлением в список, ассоциированный с \verb|epoll|-дескриптором, элементов для готовых дескрипторов. В дальнейшем вызов \verb|epoll_wait| будет извлекать данные из этого списка, не передавая какой-либо информации ядру. Следовательно, ожидаемая зависимость времени отклика \verb|epoll_wait| от числа отслеживаемых дескрипторов -- константная. 

Эксперименты с различным количеством наблюдаемых  дескрипторов для 100000 операций мониторинга, в ходе выполнения каждой из которой происходит ровно одно событие на случайном дескрипторе, для \verb|select|\footnote{Ограничение на максимальный номер дескриптора в данном эксперименте было увеличено}, \verb|poll|, \verb|epoll_wait|, проведенные М. Керриском для ядра версии 2.6 и представленные в книге "Linux API: исчерпывающее руководство"\cite{kerrisk} (см. Табл. 1), подтверждают гипотезы о характерных временах работы вызовов. %Следовательно, для отслеживания событий на большом числе дескрипторов предпочтительным является \verb|epoll|.

\begin{table}
	\centering
	\begin{tabular}{|l|l|l|l|}
		\hline
		\ Кол-во операций & poll & select & epoll \\ \hline
		10 & 0.61 & 0.73 & 0.41 \\ \hline
		100 & 2.9 & 3.0 & 0.42 \\ \hline
		1000 & 35 & 35 & 0.53 \\ \hline
		10000 & 990 & 930 & 0.66 \\ \hline
		
	\end{tabular}
	\caption{Временные расходы для select, poll, epoll в секундах для 100000 операций мониторинга различного числа дескрипторов\cite{kerrisk}}
\end{table}

\subsubsection{Сравнение}

Как следует из оценок производительности, \verb|epoll| демонстрирует лучшую масштабируемость по количеству наблюдаемых дескрипторов. 
\verb|select| и \verb|poll|, соответственно, имеют в данном случае недостатки в эффективности, однако в силу стандартизованности, \verb|select| портирован на все POSIX-совместимые,  \verb|poll| -- на большинство современных UNIX-подобных ОС соответвенно, что говорит о преимуществе их использования для кросс-платформенных приложений. Другие аспекты также играют роль при выборе конкретного примитива мультиплексирования для конкретного приложения. Приведем в Таб. 2 сравнение ключевых особенностей рассмотренных примитивов.
\begin{table}
	\centering
	\begin{tabular}{|l|l|l|l|}
		\hline
		\ Свойство & poll & select & epoll \\ \hline
		Портируемость & UNIX (+/-) & POSIX (+) &  Linux (-) \\ \hline
		Сложность поиска дескрипторов & $O(N)$ & $O(N)$ & $O(1)$ \\ \hline
		Масштабируемость & $O(N)$ & $O(N)$ & $O(1)$ \\ \hline
		Отсутствие переинициализации & + & - & + \\ \hline
		Предрассчет верхнего \verb|№| д-ра & + & - & + \\ \hline
		
	\end{tabular}
	\caption{Сравнительная таблица для poll, select и epoll}
\end{table}







\endinput